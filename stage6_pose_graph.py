import gtsam
from gtsam.utils import plot as gtsam_plot
import pickle
import numpy as np
import matplotlib.pyplot as plt


def cov_nextKF_to_currKF(kf_0, kf_k, marginals):
    """ Return the 6 x 6 covariance of the relative pose  c0 <- ck, by:
      1. Get the joint 12 × 12 covariance of (pose₀, pose_k).
      2. Invert it to information form.
      3. Slice out the conditioned block Cov(ck | c0) and invert back. """
    c_kf0 = gtsam.symbol('c', kf_0)
    c_kf1 = gtsam.symbol('c', kf_k)
    keys = gtsam.KeyVector()
    keys.append(c_kf0)
    keys.append(c_kf1)
    cov_poses_kf0_kf1 = \
        marginals.jointMarginalCovariance(keys).fullMatrix()  # marginalization is easier in cov form (12x12)
    inf_poses_kf0_kf1 = np.linalg.inv(cov_poses_kf0_kf1)  # information matrix is the inverse of cov (12x12)
    inf_kf1_cond_kf0 = inf_poses_kf0_kf1[6:, 6:]  # conditioning is easier in inofrmation form (6x6)
    cov_kf1_cond_kf0 = np.linalg.inv(inf_kf1_cond_kf0)  # switching to cov format again (6x6)
    return cov_kf1_cond_kf0


def pose_nextF_to_currKF(kf_0, kf_k, values):
    """ Compute the relative pose  c0 <- ck  from two global poses in `values`. """
    c_kf0 = gtsam.symbol('c', kf_0)
    c_kf1 = gtsam.symbol('c', kf_k)
    pose_kf0 = values.atPose3(c_kf0)
    pose_kf1 = values.atPose3(c_kf1)
    # c_KF0  <-  c_KF1
    return pose_kf0.between(pose_kf1)


def plot_trajectory_with_cov_ellipsoids(kf_ids, values, marginals, title,
                                          n_sigma=3, fignum=1):
    """ Draw a 3D trajectory plus n-sigma covariance ellipsoids for every keyframe ID. """
    fig = plt.figure(fignum); plt.clf()
    ax  = fig.add_subplot(111, projection='3d')

    for kf in kf_ids:
        key  = gtsam.symbol('c', kf)
        pose = values.atPose3(key)
        Sigma = marginals.marginalCovariance(key)     # 6×6
        # Draw camera trajectory with n-sigma ellipsoid
        gtsam_plot.plot_pose3_on_axes(ax, pose,
                                      axis_length=0.5,
                                      P = (n_sigma**2) * Sigma)  # scale radii
    gtsam_plot.set_axes_equal(fig.number)
    ax.set_xlabel("X  [m]"); ax.set_ylabel("Y  [m]"); ax.set_zlabel("Z  [m]")
    ax.set_title(title)
    plt.tight_layout()
    plt.show()


def make_pose_graph(kf_indices,
                    rel_poses,    # relative pose c_curr <- c_next
                    cond_covs):   # Cov(c_k|c_0):
    """ Build a pose-graph with:
      1. one hard prior on the first keyframe,
      2. one BetweenFactorPose3 for every consecutive KF pair,
      3. initial Values generated by chaining the relative poses into global coordinates.
    Returns (graph, initial_values). """
    graph = gtsam.NonlinearFactorGraph()
    init_vals = gtsam.Values()

    # 1) Prior on c0 (eliminates gauge freedom)
    c0 = gtsam.symbol('c', kf_indices[0])
    prior_pose = gtsam.Pose3()  # anchor at origin
    prior_sigmas = np.array([1e-6] * 6)  # essentially fixed
    prior_noise = gtsam.noiseModel.Diagonal.Sigmas(prior_sigmas)
    prior_factor = gtsam.PriorFactorPose3(c0, prior_pose, prior_noise)
    graph.add(prior_factor)
    init_vals.insert(c0, prior_pose)

    # 2) Build graph: between factors & chained initial guess
    running_pose = prior_pose
    for i, (z_ij, cov_ij) in enumerate(zip(rel_poses, cond_covs)):  # z_ij is the measurement
        k_i = kf_indices[i]
        k_j = kf_indices[i+1]
        c_i = gtsam.symbol('c', k_i)
        c_j = gtsam.symbol('c', k_j)

        noise_cov_ij = gtsam.noiseModel.Gaussian.Covariance(cov_ij)

        pose_factor = gtsam.BetweenFactorPose3(c_i, c_j, z_ij, noise_cov_ij)
        graph.add(pose_factor)

        # All poses should be kept in the coordinates (global frame)
        running_pose = running_pose.compose(z_ij)   # (world <- j) = (world <- i) @ (i <- j)
        init_vals.insert(c_j, running_pose)

    return graph, init_vals


def plot_trajectory(values, title,
                    fignum=1, scale=1):
    """ Wrapper around gtsam_plot.plot_trajectory with proper labels. """
    axis_labels = ("X  [m]", "Y  [m]", "Z  [m]")
    gtsam_plot.plot_trajectory(fignum=fignum,
                               values=values,
                               scale=scale,
                               title=title,
                               axis_labels=axis_labels)
    gtsam_plot.set_axes_equal(fignum)
    plt.tight_layout()
    plt.show()


def main(BA_PATH="all_bundles.pkl"):
    """  Performing pose-graph optimization, by following these tasks:
    1. Inspect the first bundle window
        a. print relative pose c_kf0 <- c_kf1  and its 6 x 6 conditional covariance
        b. plot bundle-1 trajectory with 3-sigma ellipsoids

    2. Build per-keyframe relative poses & covariances from all
       bundle windows (used as measurements for the pose-graph).

    3. Pose-graph optimization
        a. assemble graph (prior + between)
        b. run Levenberg–Marquardt
        c. plot trajectories before & after optimization
        d. print accumulated cost before & after
        e. plot final trajectory with 3-sigma marginal covariances
    """
    # Load bundle-adjustment results produced in Exercise 5
    with open(BA_PATH, "rb") as f:
        KF_indices, bundle_frames, graphs, result_bundles = pickle.load(f)

    # ---- Task 6.1: inspect first bundle window ----
    print("\n--- Task 6.1 ---")
    # Describe pose_kf1 in pose_kf0-coordinates
    ck_in_c0 = pose_nextF_to_currKF(KF_indices[0], KF_indices[1], result_bundles[0])
    print(f"Relative pose between the first two keyframes is:\n{ck_in_c0}")

    # For the first bundle window, compute Cov(c_kf1 | c_kf0) using Marginals
    marginal_bundle1 = gtsam.Marginals(graphs[0], result_bundles[0])
    cov_kf1_cond_kf0 = cov_nextKF_to_currKF(KF_indices[0], KF_indices[1], marginal_bundle1)
    print(f"Covariance related to relative pose between the "
          f"first two keyframes is:\n"
          f"{np.array2string(cov_kf1_cond_kf0,
                             formatter={'float_kind': lambda x: f"{x:.2e}"},
                             separator="  ",
                             max_line_width=np.inf)}\n")

    # Plot first bundle window trajectory with covariance ellipsoids
    plot_trajectory_with_cov_ellipsoids(
        kf_ids=bundle_frames[0],
        values=result_bundles[0],
        marginals=marginal_bundle1,
        title="Bundle-1: camera centers with 3-sigma ellipsoids",
        n_sigma=3)


    ## Derive relative poses & covariances for EVERY KF pair
    # Marginals for every KF pair
    marginals = [gtsam.Marginals(graph, val) for (graph, val) in zip(graphs, result_bundles)]
    KF_idx_pairs = [(KF_indices[i], KF_indices[i + 1]) for i in range(len(KF_indices) - 1)]
    # Covariances for every KF pair
    covs_next_cond_curr = [
        cov_nextKF_to_currKF(k0, k1, marg)
        for (k0, k1), marg in zip(KF_idx_pairs, marginals)
    ]
    # Poses for every KF pair
    poses_next_to_curr = [
        pose_nextF_to_currKF(k0, k1, res)
        for (k0, k1), res in zip(KF_idx_pairs, result_bundles)
    ]

    # ---- Task 6.2: build & optimize pose-graph ----
    print("\n--- Task 6.2 ---")
    # Build pose graph just out of the keyframe poses
    pose_graph, pose_values = make_pose_graph(KF_indices, poses_next_to_curr, covs_next_cond_curr)
    # Optimize this graph
    optimizer = gtsam.LevenbergMarquardtOptimizer(pose_graph, pose_values)
    pose_results = optimizer.optimize()

    # a) Plot trajectories before & after optimization
    plot_trajectory(pose_values,
                    title="Initial keyframe trajectory (before optimization)")
    plot_trajectory(pose_results,
                    title="Final keyframe trajectory (after optimization)")

    # b) Compute accumulated errors before vs. after optimization
    err_initial = pose_graph.error(pose_values)
    err_final = pose_graph.error(pose_results)
    print(f"The accumulated error BEFORE optimization is: {err_initial:.2e}")
    print(f"The accumulated error AFTER optimization is: {err_final:.2e}")

    # c) Final marginal covariances visualized
    pose_marginals = gtsam.Marginals(pose_graph, pose_results)
    plot_trajectory_with_cov_ellipsoids(
        kf_ids=KF_indices,
        values=pose_results,
        marginals=pose_marginals,
        title="All Keyframes: camera centers with 3-sigma ellipsoids (after optimization)",
        n_sigma=3,
        fignum=5)


if __name__ == '__main__':
    main()